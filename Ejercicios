    EJERCICIO 8 [BÃSICO]: AnÃ¡lisis de Suma de Elementos
    â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    
    ğŸ“ ENUNCIADO:
    Analizar la complejidad del siguiente algoritmo que suma todos los elementos
    de una lista.
    
    ğŸ”¹ PSEUDOCÃ“DIGO:
       FunciÃ³n sumaElementos(lista):
           suma â† 0
           Para cada elemento en lista:
               suma â† suma + elemento
           Retornar suma
    
    Resuelto----------------------------------------------------------------------------------
    
    def sumaElementos(lista):
        suma = 0
        for elemento in lista:
            suma = suma + elemento
        return suma
    
    #Ejemplo de Uso
    numeros = [2, 4, 6, 8, 10]
    resultado = sumaElementos(numeros)
    print("La suma de los elementos es:", resultado)
    
    #Analisis de complejidad
    """OperaciÃ³n principal: la instrucciÃ³n suma = suma + elemento
    se ejecuta una vez por cada elemento de la lista.
    Si la lista tiene N elementos:   
    El bucle for elemento in lista: se ejecuta N veces.
    Por tanto, el tiempo de ejecuciÃ³n crece linealmente con n.
    La Complejidad temporal O(n), La complejidad espacial O(1)"""
    
    EJERCICIO 9 [BÃSICO]: Comparar Complejidades
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ“ ENUNCIADO:
Ordenar las siguientes complejidades de menor a mayor eficiencia:
O(nÂ²), O(1), O(log n), O(n log n), O(2â¿), O(n), O(nÂ³)

AdemÃ¡s, indicar cuÃ¡l serÃ­a preferible para un dataset de 1 millÃ³n de elementos.


Resultado------------


complejidades = ["O(nÂ²)", "O(1)", "O(log n)", "O(n log n)", "O(2â¿)", "O(n)", "O(nÂ³)"]

ordenadas = ["O(1)", "O(log n)", "O(n)", "O(n log n)", "O(nÂ²)", "O(nÂ³)", "O(2â¿)"]

print("ğŸ”¹ Complejidades originales:")
print(complejidades)

print("\nğŸ”¹ Complejidades ordenadas de menor a mayor eficiencia:")
print(ordenadas)

print("Para un dataset de 1 millÃ³n de elementos, la mÃ¡s recomendable serÃ­a O(1)")
print("seguida de O(log n) o O(n), ya que crecen mucho mÃ¡s lento que las demÃ¡s")

    
EJERCICIO 11 [INTERMEDIO]: BÃºsqueda Binaria
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ“ ENUNCIADO:
Analizar la complejidad del algoritmo de bÃºsqueda binaria. Explicar por quÃ©
es O(log n) y en quÃ© casos es mÃ¡s eficiente que la bÃºsqueda lineal.

ğŸ”¹ PSEUDOCÃ“DIGO:
   FunciÃ³n busquedaBinaria(listaOrdenada, elemento):
       izq â† 0
       der â† longitud(listaOrdenada) - 1
       
       Mientras izq <= der:
           medio â† (izq + der) / 2
           Si listaOrdenada[medio] == elemento:
               Retornar medio
           SiNo Si listaOrdenada[medio] < elemento:
               izq â† medio + 1
           SiNo:
               der â† medio - 1
       
       Retornar -1


Resultado--------------------------------------------------------------------------------

def busquedaBinaria(listaOrdenada, elemento):
    izq = 0
    der = len(listaOrdenada) - 1

    while izq <= der:
        medio = (izq + der) // 2
        if listaOrdenada[medio] == elemento:
            return medio
        elif listaOrdenada[medio] < elemento:
            izq = medio + 1
        else:
            der = medio - 1

    return -1 


# Ejemplo de uso
lista = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]
buscado = int(input("Ingresa el nÃºmero a buscar: "))

posicion = busquedaBinaria(lista, buscado)

if posicion != -1:
    print(f"Elemento encontrado en la posiciÃ³n {posicion}.")
else:
    print("Elemento no encontrado en la lista.")

"""
AnÃ¡lisis de Complejidad:
 Mejor caso es O(1), Si el elemento se encuentra justo en el centro al primer intento.
 Peor caso es O(log n), En cada iteraciÃ³n, se descarta la mitad de la lista restante
 Caso promedio es O(log n), El nÃºmero de pasos crece logarÃ­tmicamente con el tamaÃ±o de la lista.
Â¿Por quÃ© es O(log n)?
Porque este divide el espacio de bÃºsqueda en dos mitades.
Si hay n elementos al inicio, despuÃ©s del primer paso quedan n/2, luego n/4, luego n/8, y asÃ­ sucesivamente.
El nÃºmero de veces que puede dividirse n entre 2 hasta llegar a 1 es:
k=log2(n)
Por eso, la complejidad temporal es O(log n).
y aveces es mas eficiente que la bÃºsqueda lineal porque:
Lineal (O(n))	Recorre cada elemento hasta encontrar el buscado.	
Binaria (O(log n))	Divide el rango de bÃºsqueda a la mitad en cada paso.
"""


EJERCICIO 12 [INTERMEDIO]: Complejidad con Estructuras de Datos
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ“ ENUNCIADO:
Comparar la complejidad de las siguientes operaciones en listas vs diccionarios
en Python:
- Buscar un elemento
- Insertar un elemento
- Eliminar un elemento

Indicar cuÃ¡ndo conviene usar cada estructura de datos.


