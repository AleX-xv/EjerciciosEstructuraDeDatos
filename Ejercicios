    EJERCICIO 8 [BÁSICO]: Análisis de Suma de Elementos
    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    
    📝 ENUNCIADO:
    Analizar la complejidad del siguiente algoritmo que suma todos los elementos
    de una lista.
    
    🔹 PSEUDOCÓDIGO:
       Función sumaElementos(lista):
           suma ← 0
           Para cada elemento en lista:
               suma ← suma + elemento
           Retornar suma
    
    Resuelto----------------------------------------------------------------------------------
    
    def sumaElementos(lista):
        suma = 0
        for elemento in lista:
            suma = suma + elemento
        return suma
    
    #Ejemplo de Uso
    numeros = [2, 4, 6, 8, 10]
    resultado = sumaElementos(numeros)
    print("La suma de los elementos es:", resultado)
    
    #Analisis de complejidad
    """Operación principal: la instrucción suma = suma + elemento
    se ejecuta una vez por cada elemento de la lista.
    Si la lista tiene N elementos:   
    El bucle for elemento in lista: se ejecuta N veces.
    Por tanto, el tiempo de ejecución crece linealmente con n.
    La Complejidad temporal O(n), La complejidad espacial O(1)"""
    
    EJERCICIO 9 [BÁSICO]: Comparar Complejidades
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

📝 ENUNCIADO:
Ordenar las siguientes complejidades de menor a mayor eficiencia:
O(n²), O(1), O(log n), O(n log n), O(2ⁿ), O(n), O(n³)

Además, indicar cuál sería preferible para un dataset de 1 millón de elementos.


Resultado------------


complejidades = ["O(n²)", "O(1)", "O(log n)", "O(n log n)", "O(2ⁿ)", "O(n)", "O(n³)"]

ordenadas = ["O(1)", "O(log n)", "O(n)", "O(n log n)", "O(n²)", "O(n³)", "O(2ⁿ)"]

print("🔹 Complejidades originales:")
print(complejidades)

print("\n🔹 Complejidades ordenadas de menor a mayor eficiencia:")
print(ordenadas)

print("Para un dataset de 1 millón de elementos, la más recomendable sería O(1)")
print("seguida de O(log n) o O(n), ya que crecen mucho más lento que las demás")

    
EJERCICIO 11 [INTERMEDIO]: Búsqueda Binaria
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

📝 ENUNCIADO:
Analizar la complejidad del algoritmo de búsqueda binaria. Explicar por qué
es O(log n) y en qué casos es más eficiente que la búsqueda lineal.

🔹 PSEUDOCÓDIGO:
   Función busquedaBinaria(listaOrdenada, elemento):
       izq ← 0
       der ← longitud(listaOrdenada) - 1
       
       Mientras izq <= der:
           medio ← (izq + der) / 2
           Si listaOrdenada[medio] == elemento:
               Retornar medio
           SiNo Si listaOrdenada[medio] < elemento:
               izq ← medio + 1
           SiNo:
               der ← medio - 1
       
       Retornar -1


Resultado--------------------------------------------------------------------------------

def busquedaBinaria(listaOrdenada, elemento):
    izq = 0
    der = len(listaOrdenada) - 1

    while izq <= der:
        medio = (izq + der) // 2
        if listaOrdenada[medio] == elemento:
            return medio
        elif listaOrdenada[medio] < elemento:
            izq = medio + 1
        else:
            der = medio - 1

    return -1 


# Ejemplo de uso
lista = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]
buscado = int(input("Ingresa el número a buscar: "))

posicion = busquedaBinaria(lista, buscado)

if posicion != -1:
    print(f"Elemento encontrado en la posición {posicion}.")
else:
    print("Elemento no encontrado en la lista.")

"""
Análisis de Complejidad:
 Mejor caso es O(1), Si el elemento se encuentra justo en el centro al primer intento.
 Peor caso es O(log n), En cada iteración, se descarta la mitad de la lista restante
 Caso promedio es O(log n), El número de pasos crece logarítmicamente con el tamaño de la lista.
¿Por qué es O(log n)?
Porque este divide el espacio de búsqueda en dos mitades.
Si hay n elementos al inicio, después del primer paso quedan n/2, luego n/4, luego n/8, y así sucesivamente.
El número de veces que puede dividirse n entre 2 hasta llegar a 1 es:
k=log2(n)
Por eso, la complejidad temporal es O(log n).
y aveces es mas eficiente que la búsqueda lineal porque:
Lineal (O(n))	Recorre cada elemento hasta encontrar el buscado.	
Binaria (O(log n))	Divide el rango de búsqueda a la mitad en cada paso.
"""


EJERCICIO 12 [INTERMEDIO]: Complejidad con Estructuras de Datos
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

📝 ENUNCIADO:
Comparar la complejidad de las siguientes operaciones en listas vs diccionarios
en Python:
- Buscar un elemento
- Insertar un elemento
- Eliminar un elemento

Indicar cuándo conviene usar cada estructura de datos.


